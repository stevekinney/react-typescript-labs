---
description:
globs: *.tsx,*.ts
alwaysApply: false
---

# TypeScript Best Practices

### Super Important üö®

1. **Zero-Duplication Doctrine**: If a utility already exists‚Äîuse or extend it. Re-creating it is technical vandalism.
2. **Mandatory Repo-Crawl Before Typing**: Ripgrep the codebase first. Clone code ‚Üí public PR shaming.
3. **One-Purpose Functions**: One job per function. "And also‚Ä¶" means split it or delete it.
4. **Atomic Commits or Bust**: Each commit is a surgical strike. Unrelated changes = auto-reject.
5. **DRY or Die Tryin'**: Two copies = warning. Three copies = felony. CI fails on detectable duplication.
6. **Expand, Don't Explode**: Add behavior by extending existing utils‚Äînever fork a "v2".
7. **Simplicity Tax**: If reviewers need >30 sec to grok your PR, refactor until they don't.
8. **Comment Quotas Are Real**: If code needs a paragraph to explain, the code is wrong. Refactor.
9. **Kill Dead Code on Sight**: Delete unused paths/flags/TODO fossils before they multiply.
10. **Performance Is a Feature**: New code must meet or beat existing util speed. Slower = reject.
11. **Linter = Law**: Zero ESLint/Prettier warnings. "Stylistic" excuses ‚â† defense.
12. **Context > Cleverness**: Readable beats wizardry. Explain it to a sleepy intern in <60 seconds.
13. **Guardrails > Guidelines**: Enforce via CI/git hooks. A rule that can't break the build is just cosplay.
14. **Fail Fast, Loud, Early**: Assertions everywhere. Silent fails are sabotage.
15. **Docs or It Didn't Happen**: Public utilities need JSDoc/TSDoc. Private helpers get inline types.
16. **Scope-Laser Mode**: Edit only the files absolutely required for the ticket. Touching >2 unrelated modules? Stop, commit nothing, and ping the human.

## Type Safety & Configuration

- Enable `strict: true` in @tsconfig.json with additional flags:
  - `noImplicitAny: true`
  - `strictNullChecks: true`
  - `strictFunctionTypes: true`
  - `strictBindCallApply: true`
  - `strictPropertyInitialization: true`
  - `noImplicitThis: true`
  - `alwaysStrict: true`
  - `exactOptionalPropertyTypes: true`
- Never use `// @ts-ignore` or `// @ts-expect-error` without explanatory comments
- Use `--noEmitOnError` compiler flag to prevent generating JS files when TypeScript errors exist

## Type Definitions

- Do not ever use `any`. Ever. If you feel like you have to use `any`, use `unknown` instead.
- Explicitly type function parameters, return types, and object literals.
- Please don't ever use Enums. Use a union if you feel tempted to use an Enum.
- Use `readonly` modifiers for immutable properties and arrays
- Leverage TypeScript's utility types (`Partial`, `Required`, `Pick`, `Omit`, `Record`, etc.)
- Use discriminated unions with exhaustiveness checking for type narrowing

## Advanced Patterns

- Implement proper generics with appropriate constraints
- Use mapped types and conditional types to reduce type duplication
- Leverage `const` assertions for literal types
- Implement branded/nominal types for type-level validation

## Code Organization

- Organize types in dedicated files (types.ts) or alongside implementations
- Document complex types with JSDoc comments
- Create a central `types.ts` file or a `src/types` directory for shared types

## Lint & TypeCheck Error Resolution (Lessons Learned)

### Import Path Management

- Always use path aliases (`@/` prefix) for src/ imports for consistency
- After refactoring, systematically update all import paths using search/replace
- Group imports: types first, then components, then utilities
- Use consistent import patterns across the codebase

### ESLint Rule Compliance

#### Nullish Coalescing (`??` vs `||`)

```typescript
// ‚ùå Problematic - catches falsy values like 0, false, ""
const result = value || defaultValue;

// ‚úÖ Correct - only null/undefined trigger default
const result = value ?? defaultValue;
```

#### Type Import Consistency

```typescript
// ‚úÖ Use proper type imports
import type { SomeType } from './types';

// ‚ùå Avoid import() type annotations
properties: (obj as Record<string, import('./types').SomeType>) ?? {};

properties: (obj as Record<string, SomeType>) ?? {};
```

#### No Explicit Any

```typescript
// ‚ùå Loses type safety
static tools = new Map<string, Tool<any, any>>();

// ‚úÖ Use specific constraints
static tools = new Map<string, Tool<SchemaShape | undefined, Promise<unknown>>>();
```

### Chrome Extension API Types

- Chrome API Promise return types may not match @types definitions
- Use ESLint disable comments sparingly for known async APIs:

```typescript
// eslint-disable-next-line @typescript-eslint/await-thenable
const result = await chrome.tabs.detectLanguage(tabId);
```

### Error Handling in Tests

```typescript
// ‚ùå Unused error variable
try {
  testCode();
} catch (_error) {
  // error not used
}

// ‚úÖ Bare catch when error details not needed
try {
  testCode();
} catch {
  // clean error handling
}
```

### Zod Version Compatibility

- Standardize on Zod v3 imported as `zod`
- Use standard imports: `import { z } from 'zod'`
- Define schema shapes consistently: `type SchemaShape = Record<string, z.ZodTypeAny>`

### Mock Implementation Strategy

- When services are deleted, create minimal mock implementations
- Use proper typing for mocks to maintain type safety
- Document why mocks are needed vs fixing the underlying architecture

### Security Lint Rules

- Dynamic RegExp construction triggers security warnings
- Only disable security rules when pattern is properly escaped:

```typescript
const escaped = pattern.replace(/[.+?^${}()|[\]\\]/g, '\\$&');
// eslint-disable-next-line security/detect-non-literal-regexp
const regex = new RegExp(`^${escaped}$`);
```

### Systematic Resolution Process

1. Run both `bun run lint` and `bun run typecheck` simultaneously
2. Fix import/module resolution errors first (highest priority)
3. Use `bun run lint:fix` for auto-fixable issues
4. Group similar rule fixes across all files
5. Test after each category of fixes
6. Document complex fixes with comments explaining rationale

### CRITICAL: Zod v4 Import Pattern

#### The Standard

**IMPORTANT**: This codebase uses Zod v4 with the alias pattern:

- Package.json imports both v3 and v4: `"zod": "^3.25.56"` and maps v4 to `zod/v4`
- All files should import `from 'zod/v4'` to get v4 functionality
- This ensures proper type inference for the tool system
- **Result**: Full type safety with v4 features

#### Import Pattern

```typescript
// ‚úÖ CORRECT PATTERN
import { z } from 'zod'; // Standard import

type SchemaShape = Record<string, z.ZodTypeAny>; // Compatible type definition

// All files should use this consistent pattern:
// import { z } from 'zod';
```

#### Standard Import Pattern

**1. Use v4 Imports**

```typescript
// ‚úÖ CORRECT - Use standard imports
import { z } from 'zod';

// ‚ùå WRONG - Don't use versioned imports
import { z } from 'zod/v4'; // Not in our package.json
```

**2. Type Definitions**

```typescript
// ‚úÖ CORRECT - Universal type definition
type SchemaShape = Record<string, z.ZodTypeAny>;

// This works with both v3 and v4
```

**3. Tool System Pattern**

```typescript
// Tool system uses v4 features:
export class Tool<TParams extends Record<string, z.ZodTypeAny> | undefined = undefined> {
  private constructor(
    { name, description, parameters }: ToolOptions<TParams>,
    call: ToolFunction<TParams>,
  ) {
    this.name = name;
    this.description = description;

    // ‚úÖ Using v4 with strict objects
    const params = parameters ?? ({} as Record<string, z.ZodTypeAny>);
    this.schema = z.strictObject(params); // v4 feature

    this.call = (args: unknown) => {
      const parsed = this.schema.parse(args);
      return call(parsed as InferParameters<TParams>);
    };
  }
}
```

#### Import Convention

1. **All files** should use: `import { z } from 'zod'`
2. **All schema files** should use: `import { z } from 'zod'`
3. **Consistency is key** - always use standard imports

#### Index Signature Property Access (Secondary Issue)

```typescript
// ‚ùå TypeScript strict mode error
obj.properties; // Error: use bracket notation

// ‚úÖ Fixed with bracket notation
obj['properties']; // Works with noUncheckedIndexedAccess
```

#### Verification Steps

After fixing imports, verify tool parameter types:

```typescript
// This should now properly infer parameter types instead of {}
const tool = Tool.register(
  {
    name: 'test',
    parameters: {
      url: z.string(),
      count: z.number(),
    },
  },
  async (args) => {
    // args should be { url: string; count: number } not {}
    console.log(args.url); // Should have proper typing
  },
);
```

#### Best Practices

- **Always import from `zod` for consistency**
- **Use Zod features appropriately for validation**
- **Consistent imports: `import { z } from 'zod'`**
- **Test schema validation after any Zod-related changes**

### Critical Rule: NEVER Use `any` Type

#### Why `any` is Forbidden

- **Defeats TypeScript's Purpose**: Removes all type checking and safety
- **Runtime Errors**: Allows accessing undefined properties without warnings
- **Refactoring Hazards**: Changes can break code without TypeScript detecting it
- **Loss of IntelliSense**: No autocomplete or method suggestions
- **Hidden Bugs**: Type mismatches only discovered at runtime

#### Proper Alternatives to `any`

```typescript
// ‚ùå NEVER DO THIS
function badFunction(data: any): any {
  return data.someProperty; // No type checking!
}

// ‚úÖ Use unknown with type narrowing
function goodFunction(data: unknown): string {
  if (typeof data === 'object' && data !== null && 'someProperty' in data) {
    return (data as { someProperty: string }).someProperty;
  }
  throw new Error('Invalid data structure');
}

// ‚úÖ Use generics with constraints
function betterFunction<T extends Record<string, unknown>>(data: T): T[keyof T] {
  return data[Object.keys(data)[0]!];
}

// ‚úÖ Use Zod for runtime validation + types
const schema = z.object({ someProperty: z.string() });
function bestFunction(data: unknown): string {
  const validated = schema.parse(data); // Runtime safety + compile time types
  return validated.someProperty; // Fully type-safe
}
```

#### Exception Cases (Must Be Justified)

- **Legacy Migration**: Gradual migration from JavaScript (temporary)
- **Third-party Library Issues**: Library has incorrect or missing types
- **Must Include**: Detailed comment explaining why and removal plan

```typescript
// Acceptable only with proper justification
// TODO: Remove this `any` when migrating from legacy API
// Legacy API returns dynamic structure that changes based on version
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const legacyData: any = await legacyApi.getData();
```

### Prevention Strategies

- Update tsconfig.json includes when adding new file types
- Use consistent import organization patterns
- Prefer explicit typing over inference for public APIs
- Add pre-commit hooks to catch issues early
- Regular lint/typecheck runs during development
- Test Zod schema compatibility when upgrading versions
- Use bracket notation for index signature access in strict mode
- **Always use `unknown` instead of `any` when unsure of type**
- **Implement runtime validation with Zod for external data**

## React TypeScript Patterns

### Component Type Patterns

```typescript
import { type FC, type ReactNode, type HTMLAttributes } from 'react';

// Function Component with Props
interface ButtonProps extends HTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'ghost';
  size?: 'sm' | 'md' | 'lg';
  loading?: boolean;
  children: ReactNode;
}

export const Button: FC<ButtonProps> = ({
  variant = 'primary',
  size = 'md',
  loading = false,
  children,
  className,
  disabled,
  ...props
}) => {
  return (
    <button
      className={clsx(
        'rounded-lg font-medium transition-colors',
        // Variant styles
        {
          'bg-blue-500 text-white hover:bg-blue-600': variant === 'primary',
          'bg-gray-200 text-gray-900 hover:bg-gray-300': variant === 'secondary',
          'hover:bg-gray-100': variant === 'ghost',
        },
        // Size styles
        {
          'px-3 py-1 text-sm': size === 'sm',
          'px-4 py-2': size === 'md',
          'px-6 py-3 text-lg': size === 'lg',
        },
        // State styles
        {
          'cursor-not-allowed opacity-50': disabled || loading,
        },
        className
      )}
      disabled={disabled || loading}
      {...props}
    >
      {loading ? <Spinner /> : children}
    </button>
  );
};
```

### Generic Component Pattern

```typescript
import { type ReactElement } from 'react';

interface ListProps<T> {
  items: T[];
  renderItem: (item: T, index: number) => ReactElement;
  keyExtractor?: (item: T, index: number) => string;
  emptyMessage?: string;
}

export function List<T>({
  items,
  renderItem,
  keyExtractor,
  emptyMessage = 'No items found',
}: ListProps<T>) {
  if (items.length === 0) {
    return <p className="text-gray-500">{emptyMessage}</p>;
  }

  return (
    <ul>
      {items.map((item, index) => (
        <li key={keyExtractor ? keyExtractor(item, index) : index}>
          {renderItem(item, index)}
        </li>
      ))}
    </ul>
  );
}

// Usage
<List
  items={users}
  renderItem={(user) => <UserCard user={user} />}
  keyExtractor={(user) => user.id}
/>
```

### Hook Type Patterns

```typescript
import { useState, useEffect, useCallback, useRef } from 'react';

// Custom hook with proper typing
export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);

  return debouncedValue;
}

// Hook with callback typing
export function useAsync<T>(
  callback: () => Promise<T>,
  deps: React.DependencyList = []
) {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const execute = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const result = await callback();
      setData(result);
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Unknown error');
      setError(error);
      throw error;
    } finally {
      setLoading(false);
    }
  }, deps);

  useEffect(() => {
    execute();
  }, [execute]);

  return { data, loading, error, refetch: execute };
}
```

### Event Handler Types

```typescript
import type {
  ChangeEvent,
  FormEvent,
  MouseEvent,
  KeyboardEvent,
  FocusEvent,
  DragEvent,
} from 'react';

export function Form() {
  // Form events
  const handleSubmit = (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    // Handle form submission
  };

  // Input events
  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    console.log(e.target.value);
  };

  // Select events
  const handleSelect = (e: ChangeEvent<HTMLSelectElement>) => {
    console.log(e.target.value);
  };

  // Textarea events
  const handleTextarea = (e: ChangeEvent<HTMLTextAreaElement>) => {
    console.log(e.target.value);
  };

  // Mouse events
  const handleClick = (e: MouseEvent<HTMLButtonElement>) => {
    console.log(e.currentTarget.name);
  };

  // Keyboard events
  const handleKeyDown = (e: KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      // Handle enter key
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input onChange={handleChange} onKeyDown={handleKeyDown} />
      <button onClick={handleClick}>Submit</button>
    </form>
  );
}
```

### Context Type Pattern

```typescript
import {
  createContext,
  useContext,
  useState,
  type FC,
  type ReactNode,
} from 'react';

interface ThemeContextValue {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextValue | undefined>(undefined);

interface ThemeProviderProps {
  children: ReactNode;
  defaultTheme?: 'light' | 'dark';
}

export const ThemeProvider: FC<ThemeProviderProps> = ({
  children,
  defaultTheme = 'light',
}) => {
  const [theme, setTheme] = useState<'light' | 'dark'>(defaultTheme);

  const toggleTheme = () => {
    setTheme((prev) => (prev === 'light' ? 'dark' : 'light'));
  };

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
};
```

### Ref Type Patterns

```typescript
import { useRef, forwardRef, useImperativeHandle, type Ref } from 'react';

// DOM element ref
export function InputWithFocus() {
  const inputRef = useRef<HTMLInputElement>(null);

  const focusInput = () => {
    inputRef.current?.focus();
  };

  return (
    <>
      <input ref={inputRef} />
      <button onClick={focusInput}>Focus Input</button>
    </>
  );
}

// Forward ref pattern
interface InputProps {
  label: string;
}

export const FancyInput = forwardRef<HTMLInputElement, InputProps>(
  ({ label }, ref) => {
    return (
      <label>
        {label}
        <input ref={ref} className="rounded border px-2 py-1" />
      </label>
    );
  }
);

FancyInput.displayName = 'FancyInput';

// Imperative handle pattern
interface ModalHandle {
  open: () => void;
  close: () => void;
}

interface ModalProps {
  children: ReactNode;
}

export const Modal = forwardRef<ModalHandle, ModalProps>(
  ({ children }, ref) => {
    const [isOpen, setIsOpen] = useState(false);

    useImperativeHandle(
      ref,
      () => ({
        open: () => setIsOpen(true),
        close: () => setIsOpen(false),
      }),
      []
    );

    if (!isOpen) return null;

    return <div className="modal">{children}</div>;
  }
);

Modal.displayName = 'Modal';
```
